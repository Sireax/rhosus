// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: node.proto

package node_pb

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type ChecksumType int32

const (
	ChecksumType_CHECKSUM_NULL   ChecksumType = 0
	ChecksumType_CHECKSUM_CRC32  ChecksumType = 1
	ChecksumType_CHECKSUM_CRC32C ChecksumType = 2
)

var ChecksumType_name = map[int32]string{
	0: "CHECKSUM_NULL",
	1: "CHECKSUM_CRC32",
	2: "CHECKSUM_CRC32C",
}

var ChecksumType_value = map[string]int32{
	"CHECKSUM_NULL":   0,
	"CHECKSUM_CRC32":  1,
	"CHECKSUM_CRC32C": 2,
}

func (x ChecksumType) String() string {
	return proto.EnumName(ChecksumType_name, int32(x))
}

func (ChecksumType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0c843d59d2d938e7, []int{0}
}

type NodeInfo_State int32

const (
	NodeInfo_NORMAL                   NodeInfo_State = 0
	NodeInfo_DECOMMISSION_IN_PROGRESS NodeInfo_State = 1
	NodeInfo_DECOMMISSIONED           NodeInfo_State = 2
)

var NodeInfo_State_name = map[int32]string{
	0: "NORMAL",
	1: "DECOMMISSION_IN_PROGRESS",
	2: "DECOMMISSIONED",
}

var NodeInfo_State_value = map[string]int32{
	"NORMAL":                   0,
	"DECOMMISSION_IN_PROGRESS": 1,
	"DECOMMISSIONED":           2,
}

func (x NodeInfo_State) String() string {
	return proto.EnumName(NodeInfo_State_name, int32(x))
}

func (NodeInfo_State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0c843d59d2d938e7, []int{2, 0}
}

type FileStatus_FileType int32

const (
	FileStatus_DIR     FileStatus_FileType = 0
	FileStatus_FILE    FileStatus_FileType = 1
	FileStatus_SYMLINK FileStatus_FileType = 3
)

var FileStatus_FileType_name = map[int32]string{
	0: "DIR",
	1: "FILE",
	3: "SYMLINK",
}

var FileStatus_FileType_value = map[string]int32{
	"DIR":     0,
	"FILE":    1,
	"SYMLINK": 3,
}

func (x FileStatus_FileType) String() string {
	return proto.EnumName(FileStatus_FileType_name, int32(x))
}

func (FileStatus_FileType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0c843d59d2d938e7, []int{3, 0}
}

type PingRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PingRequest) Reset()         { *m = PingRequest{} }
func (m *PingRequest) String() string { return proto.CompactTextString(m) }
func (*PingRequest) ProtoMessage()    {}
func (*PingRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c843d59d2d938e7, []int{0}
}
func (m *PingRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PingRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PingRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PingRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PingRequest.Merge(m, src)
}
func (m *PingRequest) XXX_Size() int {
	return m.Size()
}
func (m *PingRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PingRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PingRequest proto.InternalMessageInfo

type PingResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PingResponse) Reset()         { *m = PingResponse{} }
func (m *PingResponse) String() string { return proto.CompactTextString(m) }
func (*PingResponse) ProtoMessage()    {}
func (*PingResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c843d59d2d938e7, []int{1}
}
func (m *PingResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PingResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PingResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PingResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PingResponse.Merge(m, src)
}
func (m *PingResponse) XXX_Size() int {
	return m.Size()
}
func (m *PingResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PingResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PingResponse proto.InternalMessageInfo

// Information about node
type NodeInfo struct {
	Id                   string         `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Capacity             uint64         `protobuf:"varint,2,opt,name=capacity,proto3" json:"capacity,omitempty"`
	Remaining            uint64         `protobuf:"varint,3,opt,name=remaining,proto3" json:"remaining,omitempty"`
	LastUpdate           uint64         `protobuf:"varint,4,opt,name=lastUpdate,proto3" json:"lastUpdate,omitempty"`
	Location             string         `protobuf:"bytes,5,opt,name=location,proto3" json:"location,omitempty"`
	State                NodeInfo_State `protobuf:"varint,6,opt,name=state,proto3,enum=node_proto.NodeInfo_State" json:"state,omitempty"`
	CacheCapacity        uint64         `protobuf:"varint,7,opt,name=cacheCapacity,proto3" json:"cacheCapacity,omitempty"`
	CacheUsed            uint64         `protobuf:"varint,8,opt,name=cacheUsed,proto3" json:"cacheUsed,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *NodeInfo) Reset()         { *m = NodeInfo{} }
func (m *NodeInfo) String() string { return proto.CompactTextString(m) }
func (*NodeInfo) ProtoMessage()    {}
func (*NodeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c843d59d2d938e7, []int{2}
}
func (m *NodeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeInfo.Merge(m, src)
}
func (m *NodeInfo) XXX_Size() int {
	return m.Size()
}
func (m *NodeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_NodeInfo proto.InternalMessageInfo

func (m *NodeInfo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *NodeInfo) GetCapacity() uint64 {
	if m != nil {
		return m.Capacity
	}
	return 0
}

func (m *NodeInfo) GetRemaining() uint64 {
	if m != nil {
		return m.Remaining
	}
	return 0
}

func (m *NodeInfo) GetLastUpdate() uint64 {
	if m != nil {
		return m.LastUpdate
	}
	return 0
}

func (m *NodeInfo) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

func (m *NodeInfo) GetState() NodeInfo_State {
	if m != nil {
		return m.State
	}
	return NodeInfo_NORMAL
}

func (m *NodeInfo) GetCacheCapacity() uint64 {
	if m != nil {
		return m.CacheCapacity
	}
	return 0
}

func (m *NodeInfo) GetCacheUsed() uint64 {
	if m != nil {
		return m.CacheUsed
	}
	return 0
}

type FileStatus struct {
	Type                 FileStatus_FileType      `protobuf:"varint,1,opt,name=type,proto3,enum=node_proto.FileStatus_FileType" json:"type,omitempty"`
	Path                 []byte                   `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	Length               uint64                   `protobuf:"varint,3,opt,name=length,proto3" json:"length,omitempty"`
	Permission           *FileStatus_FsPermission `protobuf:"bytes,4,opt,name=permission,proto3" json:"permission,omitempty"`
	Owner                string                   `protobuf:"bytes,5,opt,name=owner,proto3" json:"owner,omitempty"`
	Group                string                   `protobuf:"bytes,6,opt,name=group,proto3" json:"group,omitempty"`
	Symlink              []byte                   `protobuf:"bytes,7,opt,name=symlink,proto3" json:"symlink,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *FileStatus) Reset()         { *m = FileStatus{} }
func (m *FileStatus) String() string { return proto.CompactTextString(m) }
func (*FileStatus) ProtoMessage()    {}
func (*FileStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c843d59d2d938e7, []int{3}
}
func (m *FileStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileStatus.Merge(m, src)
}
func (m *FileStatus) XXX_Size() int {
	return m.Size()
}
func (m *FileStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_FileStatus.DiscardUnknown(m)
}

var xxx_messageInfo_FileStatus proto.InternalMessageInfo

func (m *FileStatus) GetType() FileStatus_FileType {
	if m != nil {
		return m.Type
	}
	return FileStatus_DIR
}

func (m *FileStatus) GetPath() []byte {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *FileStatus) GetLength() uint64 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *FileStatus) GetPermission() *FileStatus_FsPermission {
	if m != nil {
		return m.Permission
	}
	return nil
}

func (m *FileStatus) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *FileStatus) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

func (m *FileStatus) GetSymlink() []byte {
	if m != nil {
		return m.Symlink
	}
	return nil
}

type FileStatus_FsPermission struct {
	Perm                 uint32   `protobuf:"varint,1,opt,name=perm,proto3" json:"perm,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileStatus_FsPermission) Reset()         { *m = FileStatus_FsPermission{} }
func (m *FileStatus_FsPermission) String() string { return proto.CompactTextString(m) }
func (*FileStatus_FsPermission) ProtoMessage()    {}
func (*FileStatus_FsPermission) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c843d59d2d938e7, []int{3, 0}
}
func (m *FileStatus_FsPermission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileStatus_FsPermission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileStatus_FsPermission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileStatus_FsPermission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileStatus_FsPermission.Merge(m, src)
}
func (m *FileStatus_FsPermission) XXX_Size() int {
	return m.Size()
}
func (m *FileStatus_FsPermission) XXX_DiscardUnknown() {
	xxx_messageInfo_FileStatus_FsPermission.DiscardUnknown(m)
}

var xxx_messageInfo_FileStatus_FsPermission proto.InternalMessageInfo

func (m *FileStatus_FsPermission) GetPerm() uint32 {
	if m != nil {
		return m.Perm
	}
	return 0
}

type DirectoryListing struct {
	Listing              []*FileStatus `protobuf:"bytes,1,rep,name=listing,proto3" json:"listing,omitempty"`
	RemainingPackages    uint32        `protobuf:"varint,2,opt,name=remainingPackages,proto3" json:"remainingPackages,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *DirectoryListing) Reset()         { *m = DirectoryListing{} }
func (m *DirectoryListing) String() string { return proto.CompactTextString(m) }
func (*DirectoryListing) ProtoMessage()    {}
func (*DirectoryListing) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c843d59d2d938e7, []int{4}
}
func (m *DirectoryListing) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DirectoryListing) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DirectoryListing.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DirectoryListing) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DirectoryListing.Merge(m, src)
}
func (m *DirectoryListing) XXX_Size() int {
	return m.Size()
}
func (m *DirectoryListing) XXX_DiscardUnknown() {
	xxx_messageInfo_DirectoryListing.DiscardUnknown(m)
}

var xxx_messageInfo_DirectoryListing proto.InternalMessageInfo

func (m *DirectoryListing) GetListing() []*FileStatus {
	if m != nil {
		return m.Listing
	}
	return nil
}

func (m *DirectoryListing) GetRemainingPackages() uint32 {
	if m != nil {
		return m.RemainingPackages
	}
	return 0
}

func init() {
	proto.RegisterEnum("node_proto.ChecksumType", ChecksumType_name, ChecksumType_value)
	proto.RegisterEnum("node_proto.NodeInfo_State", NodeInfo_State_name, NodeInfo_State_value)
	proto.RegisterEnum("node_proto.FileStatus_FileType", FileStatus_FileType_name, FileStatus_FileType_value)
	proto.RegisterType((*PingRequest)(nil), "node_proto.PingRequest")
	proto.RegisterType((*PingResponse)(nil), "node_proto.PingResponse")
	proto.RegisterType((*NodeInfo)(nil), "node_proto.NodeInfo")
	proto.RegisterType((*FileStatus)(nil), "node_proto.FileStatus")
	proto.RegisterType((*FileStatus_FsPermission)(nil), "node_proto.FileStatus.FsPermission")
	proto.RegisterType((*DirectoryListing)(nil), "node_proto.DirectoryListing")
}

func init() { proto.RegisterFile("node.proto", fileDescriptor_0c843d59d2d938e7) }

var fileDescriptor_0c843d59d2d938e7 = []byte{
	// 619 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x53, 0xcd, 0x6e, 0xd3, 0x40,
	0x10, 0xae, 0x9d, 0xdf, 0x4e, 0x7e, 0x70, 0x07, 0x54, 0xac, 0xa8, 0x0a, 0x91, 0xcb, 0x21, 0xaa,
	0x50, 0x5a, 0xa5, 0xe2, 0xc0, 0x11, 0x9c, 0x94, 0x9a, 0xe6, 0x4f, 0x6b, 0x72, 0x80, 0x4b, 0xe4,
	0x38, 0x4b, 0xb2, 0x6a, 0xe2, 0x35, 0xde, 0x0d, 0x28, 0x6f, 0xc2, 0x23, 0xf5, 0x82, 0xc4, 0x23,
	0xa0, 0xf2, 0x22, 0xc8, 0xeb, 0x26, 0x75, 0x55, 0x38, 0x79, 0xbe, 0x6f, 0xc6, 0xf3, 0xf3, 0xed,
	0x0c, 0x40, 0xc0, 0x67, 0xb4, 0x15, 0x46, 0x5c, 0x72, 0x54, 0xf6, 0x44, 0xd9, 0x56, 0x05, 0x4a,
	0x23, 0x16, 0xcc, 0x09, 0xfd, 0xba, 0xa6, 0x42, 0x5a, 0x55, 0x28, 0x27, 0x50, 0x84, 0x3c, 0x10,
	0xd4, 0xfa, 0xa9, 0x43, 0x71, 0xc0, 0x67, 0xd4, 0x09, 0xbe, 0x70, 0xac, 0x82, 0xce, 0x66, 0xa6,
	0xd6, 0xd0, 0x9a, 0xfb, 0x44, 0x67, 0x33, 0xac, 0x41, 0xd1, 0xf7, 0x42, 0xcf, 0x67, 0x72, 0x63,
	0xea, 0x0d, 0xad, 0x99, 0x25, 0x3b, 0x8c, 0x47, 0xb0, 0x1f, 0xd1, 0x95, 0xc7, 0x02, 0x16, 0xcc,
	0xcd, 0x8c, 0x72, 0xde, 0x13, 0x58, 0x07, 0x58, 0x7a, 0x42, 0x8e, 0xc3, 0x99, 0x27, 0xa9, 0x99,
	0x55, 0xee, 0x14, 0x13, 0x67, 0x5e, 0x72, 0xdf, 0x93, 0x8c, 0x07, 0x66, 0x4e, 0xd5, 0xdb, 0x61,
	0x3c, 0x83, 0x9c, 0x90, 0xf1, 0x6f, 0xf9, 0x86, 0xd6, 0xac, 0xb6, 0x6b, 0xad, 0xfb, 0x69, 0x5a,
	0xdb, 0x56, 0x5b, 0x6e, 0x1c, 0x41, 0x92, 0x40, 0x7c, 0x09, 0x15, 0xdf, 0xf3, 0x17, 0xd4, 0xde,
	0x36, 0x5b, 0x50, 0x05, 0x1f, 0x92, 0x71, 0xc7, 0x8a, 0x18, 0x0b, 0x3a, 0x33, 0x8b, 0x49, 0xc7,
	0x3b, 0xc2, 0xea, 0x42, 0x4e, 0xe5, 0x44, 0x80, 0xfc, 0x60, 0x48, 0xfa, 0x6f, 0x7b, 0xc6, 0x1e,
	0x1e, 0x81, 0xd9, 0xe9, 0xda, 0xc3, 0x7e, 0xdf, 0x71, 0x5d, 0x67, 0x38, 0x98, 0x38, 0x83, 0xc9,
	0x88, 0x0c, 0xdf, 0x93, 0xae, 0xeb, 0x1a, 0x1a, 0x22, 0x54, 0xd3, 0xde, 0x6e, 0xc7, 0xd0, 0xad,
	0x1b, 0x1d, 0xe0, 0x82, 0x2d, 0x69, 0x9c, 0x6b, 0x2d, 0xf0, 0x1c, 0xb2, 0x72, 0x13, 0x52, 0xa5,
	0x69, 0xb5, 0xfd, 0x22, 0x3d, 0xca, 0x7d, 0x94, 0x32, 0x3f, 0x6e, 0x42, 0x4a, 0x54, 0x30, 0x22,
	0x64, 0x43, 0x4f, 0x2e, 0x94, 0xe4, 0x65, 0xa2, 0x6c, 0x3c, 0x84, 0xfc, 0x92, 0x06, 0x73, 0xb9,
	0xb8, 0xd3, 0xfa, 0x0e, 0xa1, 0x0d, 0x10, 0xd2, 0x68, 0xc5, 0x84, 0x88, 0xa5, 0x8c, 0x85, 0x2e,
	0xb5, 0x8f, 0xff, 0x57, 0x46, 0x8c, 0x76, 0xa1, 0x24, 0xf5, 0x1b, 0x3e, 0x83, 0x1c, 0xff, 0x1e,
	0xd0, 0xe8, 0xee, 0x29, 0x12, 0x10, 0xb3, 0xf3, 0x88, 0xaf, 0x43, 0xf5, 0x0e, 0xfb, 0x24, 0x01,
	0x68, 0x42, 0x41, 0x6c, 0x56, 0x4b, 0x16, 0x5c, 0x2b, 0x95, 0xcb, 0x64, 0x0b, 0x6b, 0x16, 0x94,
	0xd3, 0x15, 0xd4, 0x18, 0x34, 0x5a, 0xa9, 0xd9, 0x2b, 0x44, 0xd9, 0xd6, 0x09, 0x14, 0xb7, 0xc3,
	0x62, 0x01, 0x32, 0x1d, 0x87, 0x18, 0x7b, 0x58, 0x84, 0xec, 0x85, 0xd3, 0xeb, 0x1a, 0x1a, 0x96,
	0xa0, 0xe0, 0x7e, 0xea, 0xf7, 0x9c, 0xc1, 0x95, 0x91, 0xb1, 0x22, 0x30, 0x3a, 0x2c, 0xa2, 0xbe,
	0xe4, 0xd1, 0xa6, 0xc7, 0x84, 0x8c, 0xf7, 0xea, 0x0c, 0x0a, 0xcb, 0xc4, 0x34, 0xb5, 0x46, 0xa6,
	0x59, 0x6a, 0x1f, 0xfe, 0x7b, 0x56, 0xb2, 0x0d, 0xc3, 0x57, 0x70, 0xb0, 0x5b, 0xcb, 0x91, 0xe7,
	0x5f, 0x7b, 0x73, 0x2a, 0x94, 0xb2, 0x15, 0xf2, 0xd8, 0x71, 0xf2, 0x01, 0xca, 0xf6, 0x82, 0xfa,
	0xd7, 0x62, 0xbd, 0x52, 0x3d, 0x1e, 0x40, 0xc5, 0xbe, 0xec, 0xda, 0x57, 0xee, 0xb8, 0x3f, 0x19,
	0x8c, 0x7b, 0xf1, 0x4e, 0x20, 0x54, 0x77, 0x94, 0x4d, 0xec, 0xf3, 0xb6, 0xa1, 0xe1, 0x53, 0x78,
	0xf2, 0x90, 0xb3, 0x0d, 0xbd, 0x7d, 0x09, 0xa5, 0x78, 0x5d, 0x5d, 0x1a, 0x7d, 0x63, 0x3e, 0xc5,
	0x37, 0x90, 0x8d, 0x2f, 0x0f, 0x9f, 0xa7, 0x3b, 0x4e, 0x9d, 0x66, 0xcd, 0x7c, 0xec, 0x48, 0x8e,
	0xf4, 0xdd, 0xeb, 0x9b, 0xdb, 0xba, 0xf6, 0xeb, 0xb6, 0xae, 0xfd, 0xbe, 0xad, 0x6b, 0x3f, 0xfe,
	0xd4, 0xf7, 0x3e, 0x1f, 0xcf, 0x99, 0x5c, 0xac, 0xa7, 0x2d, 0x9f, 0xaf, 0x4e, 0xa3, 0x05, 0x17,
	0x6b, 0xb1, 0xfd, 0x84, 0xd3, 0xd3, 0x24, 0xcd, 0x74, 0x9a, 0x57, 0xa9, 0xce, 0xff, 0x06, 0x00,
	0x00, 0xff, 0xff, 0xa1, 0xa3, 0x90, 0x31, 0x1b, 0x04, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// NodeServiceClient is the client API for NodeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type NodeServiceClient interface {
	Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error)
}

type nodeServiceClient struct {
	cc *grpc.ClientConn
}

func NewNodeServiceClient(cc *grpc.ClientConn) NodeServiceClient {
	return &nodeServiceClient{cc}
}

func (c *nodeServiceClient) Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error) {
	out := new(PingResponse)
	err := c.cc.Invoke(ctx, "/node_proto.NodeService/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NodeServiceServer is the server API for NodeService service.
type NodeServiceServer interface {
	Ping(context.Context, *PingRequest) (*PingResponse, error)
}

// UnimplementedNodeServiceServer can be embedded to have forward compatible implementations.
type UnimplementedNodeServiceServer struct {
}

func (*UnimplementedNodeServiceServer) Ping(ctx context.Context, req *PingRequest) (*PingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}

func RegisterNodeServiceServer(s *grpc.Server, srv NodeServiceServer) {
	s.RegisterService(&_NodeService_serviceDesc, srv)
}

func _NodeService_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServiceServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/node_proto.NodeService/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServiceServer).Ping(ctx, req.(*PingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _NodeService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "node_proto.NodeService",
	HandlerType: (*NodeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _NodeService_Ping_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "node.proto",
}

func (m *PingRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PingRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PingRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *PingResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PingResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PingResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *NodeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CacheUsed != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.CacheUsed))
		i--
		dAtA[i] = 0x40
	}
	if m.CacheCapacity != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.CacheCapacity))
		i--
		dAtA[i] = 0x38
	}
	if m.State != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Location) > 0 {
		i -= len(m.Location)
		copy(dAtA[i:], m.Location)
		i = encodeVarintNode(dAtA, i, uint64(len(m.Location)))
		i--
		dAtA[i] = 0x2a
	}
	if m.LastUpdate != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.LastUpdate))
		i--
		dAtA[i] = 0x20
	}
	if m.Remaining != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.Remaining))
		i--
		dAtA[i] = 0x18
	}
	if m.Capacity != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.Capacity))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintNode(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FileStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Symlink) > 0 {
		i -= len(m.Symlink)
		copy(dAtA[i:], m.Symlink)
		i = encodeVarintNode(dAtA, i, uint64(len(m.Symlink)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Group) > 0 {
		i -= len(m.Group)
		copy(dAtA[i:], m.Group)
		i = encodeVarintNode(dAtA, i, uint64(len(m.Group)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintNode(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Permission != nil {
		{
			size, err := m.Permission.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Length != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintNode(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FileStatus_FsPermission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileStatus_FsPermission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileStatus_FsPermission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Perm != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.Perm))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DirectoryListing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DirectoryListing) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DirectoryListing) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RemainingPackages != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.RemainingPackages))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Listing) > 0 {
		for iNdEx := len(m.Listing) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Listing[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintNode(dAtA []byte, offset int, v uint64) int {
	offset -= sovNode(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *PingRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PingResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NodeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	if m.Capacity != 0 {
		n += 1 + sovNode(uint64(m.Capacity))
	}
	if m.Remaining != 0 {
		n += 1 + sovNode(uint64(m.Remaining))
	}
	if m.LastUpdate != 0 {
		n += 1 + sovNode(uint64(m.LastUpdate))
	}
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovNode(uint64(m.State))
	}
	if m.CacheCapacity != 0 {
		n += 1 + sovNode(uint64(m.CacheCapacity))
	}
	if m.CacheUsed != 0 {
		n += 1 + sovNode(uint64(m.CacheUsed))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovNode(uint64(m.Type))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	if m.Length != 0 {
		n += 1 + sovNode(uint64(m.Length))
	}
	if m.Permission != nil {
		l = m.Permission.Size()
		n += 1 + l + sovNode(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	l = len(m.Group)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	l = len(m.Symlink)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileStatus_FsPermission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Perm != 0 {
		n += 1 + sovNode(uint64(m.Perm))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DirectoryListing) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Listing) > 0 {
		for _, e := range m.Listing {
			l = e.Size()
			n += 1 + l + sovNode(uint64(l))
		}
	}
	if m.RemainingPackages != 0 {
		n += 1 + sovNode(uint64(m.RemainingPackages))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovNode(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozNode(x uint64) (n int) {
	return sovNode(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PingRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PingRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PingRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PingResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PingResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PingResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capacity", wireType)
			}
			m.Capacity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Capacity |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remaining", wireType)
			}
			m.Remaining = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Remaining |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdate", wireType)
			}
			m.LastUpdate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUpdate |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= NodeInfo_State(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheCapacity", wireType)
			}
			m.CacheCapacity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CacheCapacity |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheUsed", wireType)
			}
			m.CacheUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CacheUsed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= FileStatus_FileType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = append(m.Path[:0], dAtA[iNdEx:postIndex]...)
			if m.Path == nil {
				m.Path = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permission", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Permission == nil {
				m.Permission = &FileStatus_FsPermission{}
			}
			if err := m.Permission.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Group = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symlink", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symlink = append(m.Symlink[:0], dAtA[iNdEx:postIndex]...)
			if m.Symlink == nil {
				m.Symlink = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileStatus_FsPermission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsPermission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsPermission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perm", wireType)
			}
			m.Perm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Perm |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DirectoryListing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DirectoryListing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DirectoryListing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Listing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Listing = append(m.Listing, &FileStatus{})
			if err := m.Listing[len(m.Listing)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainingPackages", wireType)
			}
			m.RemainingPackages = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemainingPackages |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNode(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNode
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNode
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNode
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthNode
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupNode
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthNode
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthNode        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNode          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupNode = fmt.Errorf("proto: unexpected end of group")
)
